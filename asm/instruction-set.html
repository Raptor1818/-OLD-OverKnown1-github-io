<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple 8-bit Assembler - Instruction Set Help</title>
    <link rel="stylesheet" href="./tumare.css">
    <link rel="stylesheet" href="assets/style.css">
    <style>
        @font-face{font-family: RobotoMono; src: url('fonts/RobotoMono-Regular.ttf');}
        .blacc{
            color: black;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-inverse" role="navigation" style="background-color:#141414;border:1px;border-radius:1px;">
        <div class="container">
            <div class="navbar-header">
                <a type="button" class="btn btn-default navbar-btn betterBtn" style="color: white" href="index.html">Simulator</a>
            </div>
            <div class="navbar-header navbar-right" style="padding: 10px;">
                <a class="rainbow">Simple 8-bit Assembler Simulator</a>
            </div>
        </div>
    </nav>
    <div class="container madonnazza">
        <h4>Introduction</h4>
        <p>This simulator provides a simplified assembler syntax (based on <a href="http://www.nasm.us" target="_blank">NASM</a>) and is simulating a x86 like cpu. In depth documentation and introduction to assembler can be found on the following websites:</p>
        <p>The simulator consists of a 8-bit cpu and 256 bytes of memory. All instructions (code) and variables (data) needs to fit inside the memory. For simplicity every instruction (and operand) is 1 byte. Therefore a MOV instruction will use 3 bytes of memory. The simulator provides a console output which is memory mapped from 0xE8 to 0xFF. Memory mapped means that every value written to this memory block is visible on the console.</p>
        <h4>Syntax</h4>
        <p>The syntax is similar as most assemblers are using. Every instruction must be on their own line. Labels are optional and must either start with a letter or a dot (.) and end with a colon.</p>
        <pre>label: instruction operands	; Comment</pre>
        <p>Valid number formats for constants are:</p>
<pre>
Decimal: 200
Decimal: 200d
Hex: 0xA4
Octal: 0o48
Binary: 101b
</pre>
        <p>It is possible to define a number using a character or multiple numbers (see instruction <i>DB</i>) by using a string.</p>
<pre>
Character: 'A'
String: "Hello World!"
</pre>
        <p>Operands can either be one of the four general purpose registers, stack pointer register, a memory address or a constant.
		Stack pointer register can only be used as operand in MOV, ADD, SUB, CMP, INC and DEC instructions.
		Instead of defining an address as a constant or by using a register you can use labels. The assembler will then replace the label with the corresponding constant.</p>
<pre>
General purpose (GP) register: A, B, C, D
Stack pointer register: SP
Address using a GP register: [A]
Address using a GP register and offset: [D-3]
Address using SP register and offset: [SP+2]
Address using a constant: [100]
Address using a label: label
Constant: Any number between 0..255 (8bit unsigned)
Offset for indirect addressing: Integer between -16..+15 (sign is mandatory)
</pre>
        <h4>MOV - Copy a value</h4>
        <p>Copies a value from <i>src</i> to <i>dest</i>. The MOV instruction is the only one able to directly modify the memory. SP can be used as operand with MOV.</p>
<pre>
MOV reg, reg
MOV reg, address
MOV reg, constant
MOV address, reg
MOV address, constant
</pre>
        <h4>DB - Variable</h4>
        <p>Defines a variable. A variable can either be a single number, character or a string.</p>
<pre>
DB constant
</pre>
        <h4>Math operations</h4>
        <b>Addition and Subtraction</b>
        <p>Adds two numbers together or subtract one number form another. This operations will modify the carry and zero flag. SP can be used as operand with ADD and SUB.</p>
<pre>
ADD reg, reg
ADD reg, address
ADD reg, constant
SUB reg, reg
SUB reg, address
SUB reg, constant
</pre>
        <b>Increment and Decrement</b>
        <p>Increments or decrements a register by one. This operations will modify the carry and zero flag. SP can be used as operand with INC and DEC.</p>
<pre>
INC reg
DEC reg
</pre>
        <b>Multiplication and division</b>
        <p>Multiplies or divides the <i>A</i> register with the given value. This operations will modify the carry and zero flag.</p>
<pre>
MUL reg
MUL address
MUL constant
DIV reg
DIV address
DIV constant
</pre>
        <b>Logical instructions</b>
        <p>The following logical instructions are supported: AND, OR, XOR, NOT. This operations will modify the carry and zero flag.</p>
<pre>
AND reg, reg
AND reg, address
AND reg, constant
OR reg, reg
OR reg, address
OR reg, constant
XOR reg, reg
XOR reg, address
XOR reg, constant
NOT reg
</pre>
        <b>Shift instructions</b>
        <p>The following shift instructions are supported: SHL/SAL and SHR/SAR. As this simulator only supports unsigned numbers SHR and SAR yield the same result. This operations will modify the carry and zero flag.</p>
<pre>
SHL reg, reg
SHL reg, address
SHL reg, constant
SHR reg, reg
SHR reg, address
SHR reg, constant
</pre>
        <h4>CMP - Compare</h4>
        <p>Compares two values and sets the zero flag to true if they are equal. SP can be used as operand with CMP. Use this instruction before a conditional jump.</p>
<pre>
CMP reg, reg
CMP reg, address
CMP reg, constant
</pre>
        <h4>Jumps</h4>
        <b>JMP - Unconditional jump</b>
        <p>Let the instruction pointer do a unconditional jump to the defined address.</p>
<pre>
JMP address
</pre>
        <b>Conditional jumps</b>
        <p>Let the instruction pointer do a conditional jump to the defined address. See the table below for the available conditions.</p>
        <table class="table table-condensed table-striped">
            <thead>
                <tr>
                    <th>Instruction</th>
                    <th>Description</th>
                    <th>Condition</th>
                    <th>Alternatives</th>
                </tr>
            </thead>
            <tbody>
                <tr style="color: black;">
                    <td>JC</td>
                    <td>Jump if carry</td>
                    <td>Carry = TRUE</td>
                    <td>JB, JNAE</td>
                </tr>
                <tr>
                    <td>JNC</td>
                    <td>Jump if no carry</td>
                    <td>Carry = FALSE</td>
                    <td>JNB, JAE</td>
                </tr>
                <tr style="color: black;">
                    <td>JZ</td>
                    <td>Jump if zero</td>
                    <td>Zero = TRUE</td>
                    <td>JB, JE</td>
                </tr>
                <tr>
                    <td>JNZ</td>
                    <td>Jump if no zero</td>
                    <td>Zero = FALSE</td>
                    <td>JNE</td>
                </tr>
                <tr style="color: black;">
                    <td>JA</td>
                    <td>&gt;</td>
                    <td>Carry = FALSE && Zero = FALSE</td>
                    <td>JNBE</td>
                </tr>
                <tr>
                    <td>JNBE</td>
                    <td>not &lt;=</td>
                    <td>Carry = FALSE && Zero = FALSE</td>
                    <td>JA</td>
                </tr>
                <tr style="color: black;">
                    <td>JAE</td>
                    <td>&gt;=</td>
                    <td>Carry = FALSE</td>
                    <td>JNC, JNB</td>
                </tr>
                <tr>
                    <td>JNB</td>
                    <td>not &lt;</td>
                    <td>Carry = FALSE</td>
                    <td>JNC, JAE</td>
                </tr>
                <tr style="color: black;">
                    <td>JB</td>
                    <td>&lt;</td>
                    <td>Carry = TRUE</td>
                    <td>JC, JNAE</td>
                </tr>
                <tr>
                    <td>JNAE</td>
                    <td>not &gt;=</td>
                    <td>Carry = TRUE</td>
                    <td>JC, JB</td>
                </tr>
                <tr style="color: black;">
                    <td>JBE</td>
                    <td>&lt;=</td>
                    <td>C = TRUE or Z = TRUE</td>
                    <td>JNA</td>
                </tr>
                <tr>
                    <td>JNA</td>
                    <td>not &gt;</td>
                    <td>C = TRUE or Z = TRUE</td>
                    <td>JBE</td>
                </tr>
                <tr style="color: black;">
                    <td>JE</td>
                    <td>=</td>
                    <td>Z = TRUE</td>
                    <td>JZ</td>
                </tr>
                <tr>
                    <td>JNE</td>
                    <td>!=</td>
                    <td>Z = FALSE</td>
                    <td>JNZ</td>
                </tr>
            </tbody>
        </table>
        <b>CALL - Function call</b>
        <p>Call can be used to jump into a subroutine (function). Pushes the instruction address of the next instruction to the stack and jumps to the specified address.</p>
<pre>
CALL address
</pre>
        <b>RET - Exit a subroutine</b>
        <p>Exits a subroutines by popping the return address previously pushed by the CALL instruction. Make sure the SP is balanced before calling RET otherwise the instruction pointer will have an ambiguous value.</p>
<pre>
RET
</pre>
        <h4>Stack instructions</h4>
        <b>PUSH - Push to stack</b>
        <p>Pushes a value to the stack. The stack grows down and the current position is available in the stack pointer register (SP). This instruction will decrease the SP.</p>
<pre>
PUSH reg
PUSH address
PUSH constant
</pre>
        <b>POP - Pop from stack</b>
        <p>Pops a value from the stack to a register. This instruction will increase the SP.</p>
<pre>
POP reg
</pre>
        <h4>Other instructions</h4>
        <b>HLT - Stops the processor.</b>
        <p>Stops operation of the processor. Hit Reset button to reset IP before restarting.</p>
<pre>
HLT
</pre>
        <h2>Sample programs</h2>
        <h4>String output</h4>
<pre>
JMP start:
hello:  DB "Hello World!" ; Variable
        DB 0	; String terminator

        start:
        MOV C, hello    ; Point to var 
        MOV D, 232	; Point to output
        CALL print
        HLT
   
    print:			
       MOV B, 0
    .loop:
       MOV A, [C]	; Get char from var
       MOV [D], A	; Write to output
       INC C
       INC D  
       CMP B, [C]	; Check if end
       JNZ .loop	; jump if not

       RET
</pre>
<h4>Output of a number with 2 digits</h4>
<pre>
MOV A, 21 ; Number to output
MOV B, A ; Copy number in B
MOV D, 232 ; Point to output

DIV 10  ; From 21 to 2
MUL 10  ; From 2 to 20
SUB B, A ; 21 - 20 = 1
DIV 10  ; From 20 to 2
ADD A, 48  ; Add 48 for ASCII digit code
ADD B, 48
MOV [D], A  ; Output
INC D
MOV [D], B
</pre>
<h4>Output of a number with 3 digits</h4>
<pre>
MOV A, 213 ; Number to output
MOV B, A ; Copy in register B
MOV D, 232 ; Point to output

DIV 100 ; From 213 to 2
CALL add: ; Call function
SUB A, 48  ; Reset from ASCII code to decimal
MUL 100 ; from 2 to 200
SUB B, A  ; Remove first digit from 213 (13)
MOV A, B ; Overwrite A with 13
DIV 10 ; From 13 to 1
CALL add:
SUB A, 48  
MUL 10  ; From 1 to 10
SUB B, A ; 13 - 10 = 3
ADD B, 48 
MOV [D], B ; Output last digit
HLT
 
add:
ADD A, 48 ; From decimal to ASCII
MOV [D], A ; Output
INC D  ; Next output cell
RET
</pre>
<h4>Swap numbers with stack (haram)</h4>
<pre>
MOV D, 100 ; indirizzo
MOV C, 0 ; contatore
MOV B, 1
MOV [99], 9


popolazioneC:
MOV [D], B
INC B
INC C
INC D
CMP C, [99]
JNZ popolazioneC:

MOV D, 100 ; reset indirizzo e contatore
MOV C, 0

ciclo:
PUSH [D]
INC D
INC C
CMP C, [99]
JNZ ciclo:

MOV D, 100 ; reset indirizzo e contatore
MOV C, 0

popping:
POP A
MOV [D], A
INC D
INC C
CMP C, [99]
JNZ popping:
HLT
</pre>
<h4>Swap numbers without stack (halal)</h4>
<pre>
MOV A, 100
MOV B, 1

CICLO1: 
MOV [A], B
INC A
INC B
CMP B, 5
JNE CICLO1:

CICLO2: 
MOV [A], B
DEC A
DEC B
CMP B, 0
JNE CICLO2: 

MOV B, 5
MOV A, 100

CICLO3: 
MOV [A], B
INC A
DEC B
CMP B, 0
JNE CICLO3:
HLT
</pre>
<h4>Convert lower case to upper case</h4>
<pre>
JMP start: 
var1: DB "[,.-{ stRIng }" 
DB 0 
start: 
MOV A,var1 
MOV B,232  
label: 
MOV C,[A] 
CMP C,122 
JA label2 
CMP C,97 
JB label2  
label3: 
SUB C,32 
MOV [B],C 
INC B 
INC A 
CMP D,[A] 
JNZ label 
HLT 

label2:
MOV [B],C 
INC B 
INC A 
CMP D,[A] 
JNZ label 
HLT
</pre>
<h4>Replace odd numbers with 0</h4>
<pre>
MOV A, 100 ; puntatore cella
ilpopolo:
MOV [A], B ; mettiamo 1 2 3 4 5 6 7 etc
INC A
INC B
CMP B, 10
JNZ ilpopolo:


MOV C, 100 ;nuovo puntatore cella
ciclo:
MOV A, [C] ;mettere il valore della cella 100 in A
AND A, 1 ;verifica pari o dispari
JZ next: ;se è pari allora salta
CALL sostituisci: ;sostituzione
next:
INC C ; incremento puntatore cella
INC D ; incremento contatore 
CMP D, B ;controlla se il contatore è uguale al vecchio contatore
JNZ ciclo:
HLT


sostituisci:
MOV [C], 0
RET
</pre>
<h4>Find the minimum</h4>
<pre>
MOV [99], 6

MOV [100], 89
MOV [101], 32
MOV [102], 55
MOV [103], 69
MOV [104], 22
MOV [105], 99

MOV C, 100 ; puntatore cella

MOV B, 0 ; contatore ciclo

MOV A, 0 ; contenitore num minore

ciclando:
CMP B, 0 ; se il ciclo è appena iniziato
JNZ ciclo:
MOV A, [C] ; metti il primo numero nel contenitore numero minore
JMP next:

ciclo:
MOV D, [C] ; cella temporanea

CMP D, A ; controlla se il numero è minore del numero minore registrato
JNB next: ; se non lo è, salta
MOV A, D ; se lo è, rimpiazza il vecchio numero

next:
INC B
INC C
CMP B, [99] ; controlla se il ciclo è finito
JNZ ciclando:
CALL stampa:
HLT

stampa:
MOV B, A 
MOV D, 232 

DIV 10  
MUL 10 
SUB B, A 
DIV 10  
ADD A, 48  
ADD B, 48
MOV [D], A  
INC D
MOV [D], B
RET
</pre>
    </div>
</body>
</html>
